package dev.mcarr.words.classes

import dev.mcarr.words.enums.Hint

/**
 * A single word accompanied by a hint for each letter
 * of the word.
 *
 * Used to represent a single word/row on the game display
 * which has been guessed.
 *
 * The hints are used to provide coloring which indicate
 * whether a guessed letter was correct or not.
 *
 * This class is responsible for generating hints based on
 * the player's guess versus the word generated by the game.
 *
 * @see Hint
 * @see HintedLetter
 * */
class HintedString {

    /**
     * List of strings. Each value is 1 character in length.
     *
     * This is the word guessed by the player, split up into
     * a list of characters.
     * */
    private val letters: List<String>

    /**
     * Hints generated based on the player's input.
     *
     * The number of hints should exactly match the number of
     * letters.
     * */
    private val hints: List<Hint>

    /**
     * @param displayWord The word guessed by the player
     * @param targetWord The word generated by the game, which the player
     * is trying to guess.
     * */
    constructor(
        displayWord: String,
        targetWord: String
    ){

        // Set the letters list to be the guessed word (displayWord) padded out
        // to the length of the target word (targetWord) with empty string, then
        // split into an array of strings which are 1 character each.
        this.letters = displayWord.padEnd(targetWord.length, ' ').chunked(1)

        // Split the target word into a list of strings, 1 character in length each.
        val targetChunked = targetWord.chunked(1)
        this.hints = letters
            .mapIndexed { i, letter ->

                if (letter.isBlank()){
                    return@mapIndexed Hint.NONE
                }

                if (letter !in targetChunked){
                    return@mapIndexed Hint.INCORRECT
                }


                val thisMatches = targetChunked[i] == letter

                val othersAllMatch = targetChunked.mapIndexed { index, it ->

                    // Skip index $i, since we want to check if OTHER values
                    // match. Not the current loop iteration value.
                    if (index == i) return@mapIndexed true

                    // Skip if the letters don't match. We're only checking
                    // for instances of the current letter.
                    if (letter != it) return@mapIndexed true

                    // Check if targetChunked[i] and letters[i] match.
                    // ie. If the same letter in the guessed word and the
                    // target word match up.
                    return@mapIndexed letters[index] == it
                }.all { it }

                if (othersAllMatch){
                    if (thisMatches)
                        Hint.CORRECT
                    else
                        Hint.INCORRECT
                }else{
                    if (thisMatches)
                        Hint.CORRECT_ANOTHER
                    else
                        Hint.WRONG_PLACEMENT
                }
            //
        }
        // TODO calculate hint
    }

    fun asList(): List<HintedLetter> =
        letters.mapIndexed { i, letter -> HintedLetter(letter, hints[i]) }

    fun isTargetLength(targetLength: Int): Boolean =
        letters.filter { it.isNotBlank() }.size == targetLength

}